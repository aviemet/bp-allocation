---
description: Typescript Rules
globs: *.ts, *.tsx
alwaysApply: false
---
You are an expert in TypeScript, Node.js, Vite, Vitest, Inertia.js, React, Mantine, TanStack Query, CSS, HTML, UI and UX.

## Code Style and Structure

- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Consider edge cases and error scenarios, for simple edge cases, use the "return early" pattern to avoid nesting.
- Properly structure files
  - /imports/ui/Components for all general purpose, highly reusable components.
  - /imports/ui/Layouts for all layout components.
  - /imports/lib for all non-react code.

  ### TypeScript Usage

  - Use TypeScript for all javascript code; prefer interfaces over types.
  - Write concise, technical TypeScript code with accurate examples.
  - Avoid enums; use maps instead.
  - Use functional components with TypeScript interfaces.
  - Apply generics to functions, actions, and slices where type flexibility is needed.
  - Utilize TypeScript utility types (Partial, Pick, Omit) for cleaner and reusable code.
  - Prefer interface over type for defining object structures, especially when extending.
  - Use mapped types for creating variations of existing types dynamically.
  - DO NOT USE `any`, ever! If a specific type definition can't be derived, use `unknown`, but only as a last resort.

  ### React Component Architecture

  - Use functional components with TypeScript interfaces.
  - Define components using `const`.
  - Extract reusable logic into custom hooks.
  - Implement proper component composition.
  - Implement proper cleanup in `useEffect` hooks.

  ### React Performance Optimization

  - Use `useCallback` for memoizing expensive callback functions.
  - Implement `useMemo` for expensive computations.
  - Avoid inline function definitions in JSX.
  - Implement code splitting using dynamic imports.
  - Implement proper key props in lists (avoid using index as key).
  
  ### Variable and Function Naming Patterns

  - Prefix event handlers with 'handle': handleClick, handleSubmit
  - Prefix boolean variables with verbs: isLoading, hasError, canSubmit
  - Prefix custom hooks with 'use': useAuth, useForm
  - Use complete words over abbreviations except for:
    - err (error)
    - req (request)
    - res (response)
    - props (properties)
    - ref (reference)
    - config (configuration)

  ### File Naming Conventions

  - Use lowercase with dashes for directories (e.g., components/auth-wizard).
  - Favor named exports for components.

## Syntax and Formatting

- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
- Use declarative JSX.

## Testing

- Write tests using Jest with Mocha matchers and React Testing Library
- Put test files in /tests in a folder structure which matches the file's location.

  ### Unit Testing

  - Write thorough unit tests to validate individual functions and components.
  - Use Jest and React Testing Library for reliable and efficient testing of React components.
  - Follow patterns like Arrange-Act-Assert to ensure clarity and consistency in tests.
  - Mock external dependencies and API calls to isolate unit tests.

  ### Integration Testing

  - Focus on user workflows to ensure app functionality.
  - Set up and tear down test environments properly to maintain test independence.
  - Use snapshot testing selectively to catch unintended UI changes without over-relying on it.
  - Leverage testing utilities (e.g., screen in RTL) for cleaner and more readable tests.

  ### E2E Testing

  - Use Playwright to write end to end tests, putting test files in /tests/e2e.
  - Don't mock the server, assume that the server will be running in a test environment when running e2e tests.

## Global State

- Use mobx for global state, reactive state.
- Don't store values in global state unless they are truly frontend only. Most state should be managed on the server.

## Performance Optimization

- Minimize `useEffect`, and `setState`.
- Wrap client components in Suspense with fallback.
- Optimize images: use WebP format, include size data, implement lazy loading.
