# Allocation Project Documentation

## Project Overview

### Model Organization

## Architecture Patterns

### Publications and Observers
- Server publications commonly wrap Mongo observers using a `registerObserver` utility (`imports/server/methods.ts`) that returns `{ added, changed, removed }` handlers with a shared transformer.
- Publications use `Tracker.autorun` to reactively derive IDs from one collection (e.g., `MemberThemes`) and observe another (`Members`), and tie observer/computation cleanup to the publication via `this.onStop`.

### Data Provider Hierarchy
The application uses a nested provider pattern established in `imports/ui/App.tsx`:

```
DataProvider
  └── ThemeProvider
      └── SettingsProvider
          └── OrgsProvider
              └── MembersProvider
                  └── MessagesProvider
                      └── Routes
```

This hierarchy provides global state management through MobX stores and Meteor subscriptions. Components should use the existing provider hooks (`useData()`, `useTheme()`, `useSettings()`, etc.) rather than duplicating providers.

### Meteor 3.0+ Compatibility
Server-side publications and methods must use async methods:
- `findOne()` → `findOneAsync()`
- `find().fetch()` → `find().fetchAsync()`
- `insert()` → `insertAsync()`
- `update()` → `updateAsync()`
- `remove()` → `removeAsync()`

### TanStack Router Migration
- Uses programmatic routing with `createRouter` and `createRoute`
- Nested routes under `adminLayoutRoute` for admin section
- Authentication handled in `beforeLoad` hooks
- `AdminLayout` component wraps admin routes with `<Outlet />`

### Theme Loading Pattern
- `AdminLayout` sets `data.themeId` from route params
- `ThemeProvider` subscribes to theme data based on `themeId`
- Components should handle loading states when `theme` is undefined
- Loading states prevent crashes when accessing `theme._id` before data loads

### TypeScript + SimpleSchema Pattern
- TypeScript interfaces auto-generated in `imports/api/db/generated-types.ts`
- Collections defined in `imports/api/db/index.ts` with schemas attached via `attachSchema`
- Individual schema files only contain SimpleSchema definitions
 
### Collection2 Loading in Meteor 3
- Use the static entry to ensure `attachSchema` is available at runtime: `import "meteor/aldeed:collection2/static"` before attaching schemas.
- Optional fields in SimpleSchema (`required: false`) become optional in TypeScript (`field?: type`)
- Use `npm run generate-types` to regenerate types from schemas
- All types exported from `imports/api/db/index.ts`
- Custom type generator in `scripts/generate-types-real.ts` parses actual schema files
- Generator reads your real SimpleSchema definitions and generates accurate TypeScript interfaces
- Types are saved to `imports/types/schema.ts` (replaces old manual types in `imports/types.ts`)
- Utility types are in `imports/types/utils.ts` (separate from generated schema types)
- Main types index at `imports/types/index.ts` exports both schema and utility types
- No temporary files or stale data - either works with real schemas or fails cleanly
- All imports now use the generated schema types from `/imports/types`
- Generator handles both simple type definitions (`field: Number`) and complex object definitions (`field: { type: String, required: false }`)
- Script properly parses array element types using SimpleSchema's `"fieldName.$": SchemaName` pattern
- Also handles `"fieldName.$": SchemaRegex.Id` patterns for string arrays
- Finds both exported and non-exported schema definitions to ensure all referenced types are generated
- Array fields are correctly typed as `ElementType[]` instead of `any[]` - no `any`, `unknown`, or `unknown[]` types are ever generated
- Handles all SimpleSchema types: `String`, `Number`, `Boolean`, `Date`, `Array`, `SimpleSchema.Integer`, `SchemaRegex.Id`, and `type: SchemaName` patterns
- Script filters out nested properties from function definitions and autoValue callbacks to avoid generating invalid interface properties
- **CRITICAL**: Collections must be declared with proper generic types: `new Mongo.Collection<DataType>("collectionName")`
- Data types combine schema types with TrackableData: `type MemberData = Member & TrackableData`
- This ensures `find()` methods return properly typed cursors with no type casting needed
- Store types extend schema types with additional reactive properties for MobX integration
- All data types exported from `/imports/api/db` for consistent usage across providers

### TrackableStore/TrackableCollection Pattern
- Base reactive data management system for Meteor collections
- `extendObservable` automatically makes all data fields reactive without manual declarations
- Provides consistent `_id`-based CRUD operations across all store types
- Generic pattern allows type-safe extension for specific domain stores
- Integrates with Meteor's reactive data flow through `refreshData` method
- Collection constructors handle store instantiation with proper type assertions using `as new (data: TrackableData) => StoreType`
- Store constructors accept specific data types (MemberData, OrgData, etc.) for full type safety

### Form + Validation Pattern
- `imports/ui/Components/Form/Form.tsx` is the shared form wrapper.
- Uses React Hook Form for state and integrates SimpleSchema validation via `schema.newContext()`.
- `onValidSubmit(data, methods)` is debounced (leading edge) to prevent double submits.
- `onUpdate(partialData)` is driven by `watch()` per-field updates; sanitization can run before validation of the specific key.
- `onChange(methods)` is a generic change subscription when full form-level reactions are needed.

### Documentation Rules
- ONLY document architectural decisions and WHY choices were made
- NEVER document implementation details, HOW things work, or specific code patterns
- If it would become outdated quickly or is obvious from reading the code, don't document it
- Focus on non-obvious reasoning behind architectural choices

### TypeScript Type Strategy
- Rely on TypeScript's type inference for derived types instead of explicit annotations
- Only add explicit types when TypeScript cannot infer them (e.g., generic constructors, complex union types, Promise return types)
- Avoid redundant type annotations that duplicate what the type system already knows
- Trust the compiler to derive types from initial values and context
- Remove explicit return types for simple functions where TypeScript can infer the type from the implementation

### Meteor Package Type Declarations
- Custom type declarations for Meteor packages without built-in TypeScript support
- Type declarations stored in `imports/types/` directory (e.g., `meteor-mdg-validated-method.d.ts`, `mongo.d.ts`)
- Include custom declarations in `tsconfig.json` under the `include` array
- ValidatedMethod type declarations provide proper typing for method options, call signatures, and execution methods
- Fix method calls to use `.call()` syntax for ValidatedMethod instances instead of direct function calls
- MongoDB type extensions in `mongo.d.ts` provide enhanced `$pull` support for complex queries on object arrays
- The default Meteor MongoDB types are too restrictive for complex `$pull` operations like `{ _id: { $in: [...] } }`
- Module augmentation extends `Mongo.Modifier` to accept any valid MongoDB operation without requiring type casts

### Method Parameter Typing Pattern
- Leverage existing schema types using TypeScript utility types (`Partial<T>`, `Pick<T, K>`)
- Extend schema types for method-specific requirements rather than duplicating field definitions
- Use `Partial<Member>` for optional member fields, `Pick<Member, "field1" | "field2">` for required fields
- Create minimal interfaces that extend schema types only when additional fields are needed
- Define return types explicitly for all methods to ensure type safety
- Use proper error handling with typed callbacks and Promise rejection patterns

### NEVER USE `any` - CRITICAL RULE
- **ABSOLUTELY FORBIDDEN**: Never use `any` as a type definition
- **NEVER EVER**: No exceptions, no shortcuts, no "just this once"
- **ALWAYS**: Use proper type assertions, union types, or generic constraints instead
- **IF STUCK**: Use `unknown` and narrow the type, or create proper interfaces
- **TYPE ASSERTIONS**: Use `as unknown as SpecificType` when necessary, never `as any`
- **GENERIC CONSTRAINTS**: Use proper generic bounds instead of `any`
- **INTERSECTION TYPES**: Use `TypeA & TypeB` for combining types
- **MAPPED TYPES**: Use utility types like `Partial<T>`, `Pick<T, K>`, `Omit<T, K>`
- **UNION TYPES**: Use `string | number` instead of `any`
- **RECORD TYPES**: Use `Record<string, unknown>` instead of `any`

### NO TYPE CASTING - CRITICAL RULE
- **ABSOLUTELY FORBIDDEN**: Type casting is NOT an acceptable way to handle TypeScript errors
- **NEVER CAST**: Do not use `as` to force types - this defeats the purpose of TypeScript
- **FIX THE ROOT CAUSE**: If you need to cast, the types are wrong - fix the actual type definitions
- **PROPER SOLUTIONS**: 
  - Fix the source type definitions to be correct
  - Use proper generic constraints
  - Create proper interfaces that match the actual data structure
  - Use type guards with `unknown` and narrowing
  - Use intersection types to combine existing types
- **WHEN STUCK**: If you think you need to cast, step back and fix the underlying type system
- **TYPE ASSERTIONS ONLY**: The only acceptable use of `as` is for type assertions with `unknown` when you've properly narrowed the type
- **NO SHORTCUTS**: Type casting is a shortcut that breaks type safety - never use it

### Provider Data Loading Pattern
- Providers should start with data loading enabled by default to avoid race conditions
- `MembersProvider` starts with `subLimit: false` to immediately load members when `themeId` is available
- Remove `useEffect` calls that trigger data loading in provider hooks - let the provider handle loading automatically
- Server publications handle the actual data filtering (e.g., theme-based member filtering)
- Client-side queries should be simple since the server publication does the heavy lifting

### Meteor File Loading Behavior
- Meteor eagerly loads and executes any `.js/.ts` files at the project root (outside of `imports/`, `client/`, and `server/`).
- Utility scripts placed in `scripts/` at the root will be executed on server startup if they have top-level code.
- To avoid accidental execution:
  - Place scripts under `imports/` (and only import when needed), or `private/` if treated as assets; and/or
  - Ensure scripts have no top-level side effects and gate execution behind an environment variable check.

### Component Props Typing
- Replace PropTypes with TypeScript interfaces for all React component props
- Use existing data types from `/imports/api/db` for prop types (e.g., `MessageData`, `MemberData`)
- For MUI components, extend built-in prop types using `Omit` to exclude conflicting props (e.g., `Omit<ButtonProps, "onClick">`)
- Use index signatures for dynamic object properties when structure varies (e.g., `[key: string]: string | number | undefined`)
- Remove all PropTypes declarations when adding TypeScript interfaces
