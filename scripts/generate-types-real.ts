#!/usr/bin/env ts-node
/* eslint-disable no-console */

// Real solution: Parse actual schema files and generate types
// No temporary files, no stale data - either works with real schemas or fails

import * as fs from "fs"
import * as path from "path"

console.log("Generating TypeScript types from actual SimpleSchema definitions...")

// Parse SimpleSchema from file content
function parseSchemaFromFile(filePath: string): Record<string, string> {
	if(!fs.existsSync(filePath)) {
		throw new Error(`Schema file not found: ${filePath}`)
	}

	const content = fs.readFileSync(filePath, "utf8")
	const schemas: Record<string, string> = {}

	// Find all SimpleSchema exports
	const schemaMatches = [...content.matchAll(/export const (\w+Schema) = new SimpleSchema\(/g)]

	for(const match of schemaMatches) {
		const schemaName = match[1]
		console.log(`Found schema: ${schemaName} in ${path.basename(filePath)}`)

		// Extract the schema definition by finding the matching closing parenthesis
		const startIndex = content.indexOf(match[0])
		let braceCount = 0
		let endIndex = startIndex
		let inString = false
		let stringChar = ""

		for(let i = startIndex; i < content.length; i++) {
			const char = content[i]
			const prevChar = i > 0 ? content[i - 1] : ""

			if(!inString && (char === '"' || char === "'" || char === "`")) {
				inString = true
				stringChar = char
			} else if(inString && char === stringChar && prevChar !== "\\") {
				inString = false
			} else if(!inString) {
				if(char === "{") {
					braceCount++
				} else if(char === "}") {
					braceCount--
					if(braceCount === 0) {
						endIndex = i
						break
					}
				}
			}
		}

		if(endIndex === startIndex) {
			throw new Error(`Could not parse schema ${schemaName} in ${filePath}`)
		}

		schemas[schemaName] = content.substring(startIndex, endIndex + 1)
	}

	return schemas
}


// Parse schema definition and generate TypeScript interface
function generateInterfaceFromSchema(schemaName: string, schemaContent: string): string {
	// This is a simplified parser - in a real implementation you'd use a proper AST parser
	// For now, we'll extract the key information we need

	const lines = schemaContent.split("\n")
	const fields: string[] = []

	// Extract field definitions
	let hasExplicitId = false

	for(let i = 0; i < lines.length; i++) {
		const line = lines[i].trim()

		// Look for field definitions
		if(line.match(/^\w+:\s*\{/)) {
			const fieldName = line.split(":")[0].trim()

			// Check if this is an explicit _id field
			if(fieldName === "_id") {
				hasExplicitId = true
			}

			// Look for type and required properties
			let type = "unknown"
			let isOptional = true

			for(let j = i; j < lines.length && !lines[j].includes("},"); j++) {
				const fieldLine = lines[j].trim()

				if(fieldLine.includes("type: String")) {
					type = "string"
				} else if(fieldLine.includes("type: Number")) {
					type = "number"
				} else if(fieldLine.includes("type: Boolean")) {
					type = "boolean"
				} else if(fieldLine.includes("type: Date")) {
					type = "Date"
				} else if(fieldLine.includes("type: Array")) {
					type = "any[]"
				} else if(fieldLine.includes("required: true")) {
					isOptional = false
				} else if(fieldLine.includes("allowedValues:")) {
					// Extract enum values
					const enumMatch = fieldLine.match(/\[(.*?)\]/)
					if(enumMatch) {
						const values = enumMatch[1].split(",").map(v => v.trim().replace(/['"]/g, ""))
						type = values.map(v => `"${v}"`).join(" | ")
					}
				}
			}

			// _id is always required in MongoDB/Meteor, even if schema says required: false
			if(fieldName === "_id") {
				isOptional = false
			}

			const optionalMark = isOptional ? "?" : ""
			fields.push(`\t${fieldName}${optionalMark}: ${type};`)
		}
	}

	// Add _id field only if not explicitly defined in schema
	const allFields = hasExplicitId ? fields : [`\t_id: string;`, ...fields]

	return `export interface ${schemaName.replace("Schema", "")} {\n${allFields.join("\n")}\n}`
}

// Main generation function
function generateTypes(): void {
	try {
		const schemaFiles = [
			"Members.ts",
			"Themes.ts",
			"Organizations.ts",
			"MemberThemes.ts",
			"Messages.ts",
			"PresentationSettings.ts",
		]

		const allSchemas: Record<string, string> = {}

		// Parse all schema files
		for(const fileName of schemaFiles) {
			const filePath = path.join(process.cwd(), "imports/api/db", fileName)
			const schemas = parseSchemaFromFile(filePath)
			Object.assign(allSchemas, schemas)
		}

		if(Object.keys(allSchemas).length === 0) {
			throw new Error("No schemas found in any of the schema files")
		}

		console.log(`Parsed ${Object.keys(allSchemas).length} schemas from ${schemaFiles.length} files`)

		// Generate TypeScript interfaces
		let content = `// This file is auto-generated by schema-to-types
// Do not edit manually - run 'npm run generate-types' to regenerate

// Generated types based on SimpleSchema definitions

`

		for(const [schemaName, schemaContent] of Object.entries(allSchemas)) {
			const interfaceName = schemaName.replace("Schema", "")
			const interfaceDef = generateInterfaceFromSchema(interfaceName, schemaContent)
			content += interfaceDef + "\n\n"
		}

		// Write the generated types file to the proper location
		const outputPath = path.join(process.cwd(), "imports/types/schema.ts")
		fs.writeFileSync(outputPath, content)

		console.log("‚úÖ Type generation completed successfully!")
		console.log(`üìÅ Generated types written to: ${outputPath}`)

	} catch(error) {
		console.error("‚ùå Type generation failed:", (error as Error).message)
		console.log("\nüí° This means the script could not parse your actual schema files")
		console.log("   Check that your schema files exist and have the correct format")
		process.exit(1)
	}
}

// Run the generation
generateTypes()
