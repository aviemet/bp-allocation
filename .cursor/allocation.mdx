# Allocation Project Documentation

## Project Overview

### Model Organization

## Architecture Patterns

### Publications and Observers
- Server publications commonly wrap Mongo observers using a `registerObserver` utility (`imports/server/methods.ts`) that returns `{ added, changed, removed }` handlers with a shared transformer.
- Publications use `Tracker.autorun` to reactively derive IDs from one collection (e.g., `MemberThemes`) and observe another (`Members`), and tie observer/computation cleanup to the publication via `this.onStop`.
- Tracker server reactivity still relies on synchronous reads; use `find()` / `findOne()` / `fetch()` inside the autorun and avoid awaiting `fetchAsync` or `findOneAsync` in the reactive block, otherwise downstream subscribers stop receiving updates.
- To keep Meteor 3 async fetches reactive, publications now pair lightweight `observeChanges` watchers with a single live query handle; watchers trigger a debounced async refresh that refetches the dependent data and restarts the shared observer without spawning duplicate handles.
- Publications that derive membership through join tables must diff published IDs before recreating their observers (`imports/server/publications/members.ts`). The diff explicitly emits `removed` messages for IDs dropped from the join table and reuses the shared transformer so downstream UI collections immediately drop stale rows when the join changes.

### Data Provider Hierarchy
The application uses a nested provider pattern established in `imports/ui/App.tsx`:

```
DataProvider
  └── ThemeProvider
      └── SettingsProvider
          └── OrgsProvider
              └── MembersProvider
                  └── MessagesProvider
                      └── Routes
```

This hierarchy provides global state management through MobX stores and Meteor subscriptions. Components should use the existing provider hooks (`useData()`, `useTheme()`, `useSettings()`, etc.) rather than duplicating providers.

### Meteor 3.0+ Compatibility
Server-side publications and methods must use async methods:
- `findOne()` → `findOneAsync()`
- `find().fetch()` → `find().fetchAsync()`
- `insert()` → `insertAsync()`
- `update()` → `updateAsync()`
- `remove()` → `removeAsync()`
- Client-side ValidatedMethod calls must use async variants:
  - `Method.call()` → `Method.callAsync()`
  - `Method.apply()` → `Method.applyAsync()`
- **IMPORTANT**: When calling ValidatedMethod from within another server method, `.callAsync()` may hang - directly access collections instead of calling another method

### TanStack Router Migration
- Uses programmatic routing with `createRouter` and `createRoute`
- Nested routes under `adminLayoutRoute` for admin section
- Authentication handled in `beforeLoad` hooks
- `AdminLayout` component wraps admin routes with `<Outlet />`
- Route wrapper components handle data loading and theme ID initialization
- Components used in multiple routes should use `useParams({ strict: false })` instead of specifying `from` route path

### Theme Loading Pattern
- `AdminLayout` sets `data.themeId` from route params
- `ThemeProvider` subscribes to theme data based on `themeId`
- Components should handle loading states when `theme` is undefined
- Loading states prevent crashes when accessing `theme._id` before data loads

### TypeScript + SimpleSchema Pattern
- TypeScript interfaces auto-generated in `imports/api/db/generated-types.ts`
- Collections defined in `imports/api/db/index.ts` with schemas attached via `attachSchema`
- Individual schema files only contain SimpleSchema definitions
 
### Collection2 Loading in Meteor 3
- Use the static entry to ensure `attachSchema` is available at runtime: `import "meteor/aldeed:collection2/static"` before attaching schemas.
- Optional fields in SimpleSchema (`required: false`) become optional in TypeScript (`field?: type`)
- Use `npm run generate-types` to regenerate types from schemas
- All types exported from `imports/api/db/index.ts`
- Custom type generator in `scripts/generate-types-real.ts` parses actual schema files
- Generator reads your real SimpleSchema definitions and generates accurate TypeScript interfaces
- Types are saved to `imports/types/schema.ts` (replaces old manual types in `imports/types.ts`)
- Utility types are in `imports/types/utils.ts` (separate from generated schema types)
- Main types index at `imports/types/index.ts` exports both schema and utility types
- No temporary files or stale data - either works with real schemas or fails cleanly
- All imports now use the generated schema types from `/imports/types`
- Generator handles both simple type definitions (`field: Number`) and complex object definitions (`field: { type: String, required: false }`)
- Script properly parses array element types using SimpleSchema's `"fieldName.$": SchemaName` pattern
- Also handles `"fieldName.$": SchemaRegex.Id` patterns for string arrays
- Finds both exported and non-exported schema definitions to ensure all referenced types are generated
- Array fields are correctly typed as `ElementType[]` instead of `any[]` - no `any`, `unknown`, or `unknown[]` types are ever generated
- Handles all SimpleSchema types: `String`, `Number`, `Boolean`, `Date`, `Array`, `SimpleSchema.Integer`, `SchemaRegex.Id`, and `type: SchemaName` patterns
- Script filters out nested properties from function definitions and autoValue callbacks to avoid generating invalid interface properties
- **CRITICAL**: Collections must be declared with proper generic types: `new Mongo.Collection<DataType>("collectionName")`
- Data types combine schema types with TrackableData: `type MemberData = Member & TrackableData`
- This ensures `find()` methods return properly typed cursors with no type casting needed
- Store types extend schema types with additional reactive properties for MobX integration
- All data types exported from `/imports/api/db` for consistent usage across providers

### TrackableStore/TrackableCollection Pattern
- Base reactive data management system for Meteor collections
- `extendObservable` automatically makes all data fields reactive without manual declarations
- Provides consistent `_id`-based CRUD operations across all store types
- Generic pattern allows type-safe extension for specific domain stores
- Integrates with Meteor's reactive data flow through `refreshData` method
- Collection constructors handle store instantiation with proper type assertions using `as new (data: TrackableData) => StoreType`
- Store constructors accept specific data types (MemberData, OrgData, etc.) for full type safety
- When computed getters return transformed data that needs generic component compatibility (e.g., SortableTable's index signature requirement), export the transformed type from the store/collection file rather than defining it at consumer level - this ensures type consistency and prevents duplication

### Form + Validation Pattern
- `imports/ui/Components/Form/Form.tsx` is the shared form wrapper.
- Uses React Hook Form for state and integrates SimpleSchema validation via `schema.newContext()`.
- `onValidSubmit(data, methods)` is debounced (leading edge) to prevent double submits.
- `onUpdate(partialData)` is driven by `watch()` per-field updates; sanitization can run before validation of the specific key.
- `onChange(methods)` is a generic change subscription when full form-level reactions are needed.

### Pledge Animation Queue Pattern
- Animation queue is a server-side Meteor collection (`PledgeAnimationQueue`) - single source of truth
- Queue items have `processed` boolean flag to track animation status
- Two ways items enter the queue:
  1. New pledge from database → inserted via Method on first page load
  2. Replay button clicked → inserted via Method
- `PledgesOverlay` subscribes to unprocessed queue items, animates in timestamp order
- After animation completes, item is marked `processed: true` and removed from subscription
- Cross-tab sync happens automatically via Meteor's DDP - no client-side state needed
- Clean architecture: server owns the queue, clients just consume and mark as processed

### Documentation Rules
- ONLY document architectural decisions and WHY choices were made
- NEVER document implementation details, HOW things work, or specific code patterns
- If it would become outdated quickly or is obvious from reading the code, don't document it
- Focus on non-obvious reasoning behind architectural choices

### TypeScript Type Strategy
- Rely on TypeScript's type inference for derived types instead of explicit annotations
- Only add explicit types when TypeScript cannot infer them (e.g., generic constructors, complex union types, Promise return types)
- Avoid redundant type annotations that duplicate what the type system already knows
- Trust the compiler to derive types from initial values and context
- Remove explicit return types for simple functions where TypeScript can infer the type from the implementation

### Meteor Package Type Declarations
- Custom type declarations for Meteor packages without built-in TypeScript support
- Type declarations stored in `imports/types/` directory (e.g., `meteor-mdg-validated-method.d.ts`, `mongo.d.ts`)
- Include custom declarations in `tsconfig.json` under the `include` array
- ValidatedMethod type declarations provide proper typing for method options, call signatures, and execution methods
- Fix method calls to use `.call()` syntax for ValidatedMethod instances instead of direct function calls
- MongoDB type extensions in `mongo.d.ts` provide enhanced `$pull` support for complex queries on object arrays
- The default Meteor MongoDB types are too restrictive for complex `$pull` operations like `{ _id: { $in: [...] } }`
- Module augmentation extends `Mongo.Modifier` to accept any valid MongoDB operation without requiring type casts

### Method Parameter Typing Pattern
- Leverage existing schema types using TypeScript utility types (`Partial<T>`, `Pick<T, K>`)
- Extend schema types for method-specific requirements rather than duplicating field definitions
- Use `Partial<Member>` for optional member fields, `Pick<Member, "field1" | "field2">` for required fields
- Create minimal interfaces that extend schema types only when additional fields are needed
- Define return types explicitly for all methods to ensure type safety
- Use proper error handling with typed callbacks and Promise rejection patterns

### NEVER USE `any` - CRITICAL RULE
- **ABSOLUTELY FORBIDDEN**: Never use `any` as a type definition
- **NEVER EVER**: No exceptions, no shortcuts, no "just this once"
- **ALWAYS**: Use proper type assertions, union types, or generic constraints instead
- **IF STUCK**: Use `unknown` and narrow the type, or create proper interfaces
- **TYPE ASSERTIONS**: Use `as unknown as SpecificType` when necessary, never `as any`
- **GENERIC CONSTRAINTS**: Use proper generic bounds instead of `any`
- **INTERSECTION TYPES**: Use `TypeA & TypeB` for combining types
- **MAPPED TYPES**: Use utility types like `Partial<T>`, `Pick<T, K>`, `Omit<T, K>`
- **UNION TYPES**: Use `string | number` instead of `any`
- **RECORD TYPES**: Use `Record<string, unknown>` instead of `any`

### NO TYPE CASTING - CRITICAL RULE
- **ABSOLUTELY FORBIDDEN**: Type casting is NOT an acceptable way to handle TypeScript errors
- **NEVER CAST**: Do not use `as` to force types - this defeats the purpose of TypeScript
- **FIX THE ROOT CAUSE**: If you need to cast, the types are wrong - fix the actual type definitions
- **PROPER SOLUTIONS**: 
  - Fix the source type definitions to be correct
  - Use proper generic constraints
  - Create proper interfaces that match the actual data structure
  - Use type guards with `unknown` and narrowing
  - Use intersection types to combine existing types
- **WHEN STUCK**: If you think you need to cast, step back and fix the underlying type system
- **TYPE ASSERTIONS ONLY**: The only acceptable use of `as` is for type assertions with `unknown` when you've properly narrowed the type
- **NO SHORTCUTS**: Type casting is a shortcut that breaks type safety - never use it

### Provider Data Loading Pattern
- Providers should start with data loading enabled by default to avoid race conditions
- `MembersProvider` starts with `subLimit: false` to immediately load members when `themeId` is available
- Remove `useEffect` calls that trigger data loading in provider hooks - let the provider handle loading automatically
- Server publications handle the actual data filtering (e.g., theme-based member filtering)
- Client-side queries should be simple since the server publication does the heavy lifting

### Data Loading Race Condition Prevention
- **Critical Fix**: Publications now fetch and publish initial data synchronously BEFORE setting up observers and calling `this.ready()`. This ensures `subscription.ready()` means data is actually synced to the client.
- **Publication Pattern**: 
  1. Fetch initial data with `fetchAsync()`
  2. Publish it synchronously using observer callbacks (e.g., `observerCallbacks.added(doc)`)
  3. Then set up the observer for future changes
  4. Only then call `this.ready()`
- This eliminates the race condition where `ready()` fired before observer callbacks completed
- Collections must be initialized synchronously when subscriptions become ready, not only in `onReady` callbacks
- Server publications in `Tracker.autorun` must call `this.ready()` in ALL code paths, including early returns when data doesn't exist
- Publications that return early without data must explicitly call `this.ready()` to prevent endless loading states

### Meteor File Loading Behavior
- Meteor eagerly loads and executes any `.js/.ts` files at the project root (outside of `imports/`, `client/`, and `server/`).
- Utility scripts placed in `scripts/` at the root will be executed on server startup if they have top-level code.
- To avoid accidental execution:
  - Place scripts under `imports/` (and only import when needed), or `private/` if treated as assets; and/or
  - Ensure scripts have no top-level side effects and gate execution behind an environment variable check.

### Component Props Typing
- Replace PropTypes with TypeScript interfaces for all React component props
- Use existing data types from `/imports/api/db` for prop types (e.g., `MessageData`, `MemberData`)
- For MUI components, extend built-in prop types using `Omit` to exclude conflicting props (e.g., `Omit<ButtonProps, "onClick">`)
- Use index signatures for dynamic object properties when structure varies (e.g., `[key: string]: string | number | undefined`)
- Remove all PropTypes declarations when adding TypeScript interfaces

### Schema Type Generation
- Type generation script (`scripts/generate-types-real.ts`) distinguishes between collection-level and embedded schemas
- Collection-level schemas (used with `.attachSchema()` in `index.ts`) automatically get `_id: string` added to their generated types
- Embedded schemas (like `RoundsSchema`, `OrgChitVoteSummary`) do NOT get `_id` added - they're embedded documents without their own identity
- The script parses `imports/api/db/index.ts` to identify which schemas are attached to Mongo collections
- `OrgChitVoteSummary` is an embedded document type (used in Organization.chitVotes), distinct from `ChitVote` (used in MemberTheme.chitVotes)
- When schemas with the same base name exist in different files, ensure they serve different purposes and have unique type names

### Chit Voting System Architecture
The application supports two modes of chit voting controlled by `PresentationSettings.useKioskChitVoting`r:

**Manual Mode (useKioskChitVoting = false)**:
- Historical mode for physical wooden chits placed in boxes
- Admins weigh/count chits and manually enter data in `ManualInputTable`
- Data stored in `Organization.chitVotes` as `OrgChitVoteSummary { weight?: number, count?: number }`
- `count` takes precedence over `weight` when both present
- `weight` divided by `Theme.chitWeight` to calculate vote count
- One summary record per organization

**Kiosk Mode (useKioskChitVoting = true)**:
- Digital voting through the application interface
- Members distribute chits across organizations using `ChitTicker` component
- Data stored in `MemberTheme.chitVotes[]` as array of `ChitVote { organization, votes, voteSource, createdAt }`
- One `ChitVote` record per organization per member
- `OrgTransformer` aggregates votes from all member records

The two data structures serve different purposes and should not be conflated:
- `OrgChitVoteSummary`: Aggregate summary for manual entry (no _id needed)
- `ChitVote`: Individual vote records for kiosk mode (needs _id for array updates)

### Test Structure
- Test files use `.test.ts` or `.spec.ts` naming convention so Meteor only loads them during `meteor test`
- Test files are co-located with the code they test (e.g., `Members.test.ts` next to `Members.ts`)
- Mock/fixture files use `.mock.ts` suffix and live in `/imports/mock/` - they're only loaded via explicit imports
- The `/tests/` directory is reserved for external test runners (Cypress) and files Meteor should completely ignore

### Test Database Reset Helper
- Unit and integration tests reset their database state through `imports/tests/resetDatabase`, which calls `MongoInternals.defaultRemoteCollectionDriver().mongo.db.dropDatabase()`; this targets only the isolated database started for the current Meteor test process.

### Timer Management in React + Meteor
- Use `useRef` to store timer IDs and prevent recreation on each render
- Use `useCallback` for timer callback functions to stabilize references
- Always cleanup timers in `useEffect` cleanup functions to prevent memory leaks
- This pattern prevents "Can't set timers inside simulations" errors when using timers in MobX observer components

### External Library Type Declarations
- Custom type declaration files for untyped NPM packages go in `/imports/types/`
- Use `declare module "package-name"` syntax with minimal type definitions
- Files are auto-discovered by TypeScript via `tsconfig.json` include patterns

### React 19 Key Prop Handling
- React 19 prohibits spreading props that contain a `key` property
- MUI Autocomplete's `renderOption` passes props containing `key` 
- Pattern: destructure `key` from props and pass it separately: `const { key, ...otherProps } = props; return <Component key={key} {...otherProps} />`
- This applies to any render prop that receives React-generated props with keys

### Question vs Action - CRITICAL RULE
- **WHEN USER ASKS A QUESTION**: Answer the question only. Do NOT make code changes.
- **WHEN USER ASKS FOR ACTION**: Then make the requested changes.
- **NEVER**: Assume a question is a request to fix something - questions are requests for information, not action.
- If a question points out a problem, answer where/how it's calculated/defined, don't fix it unless explicitly asked.
