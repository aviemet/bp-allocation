# Allocation Project Documentation

## Project Overview

### Model Organization

## Architecture Patterns

### Data Provider Hierarchy
The application uses a nested provider pattern established in `imports/ui/App.tsx`:

```
DataProvider
  └── ThemeProvider
      └── SettingsProvider
          └── OrgsProvider
              └── MembersProvider
                  └── MessagesProvider
                      └── Routes
```

This hierarchy provides global state management through MobX stores and Meteor subscriptions. Components should use the existing provider hooks (`useData()`, `useTheme()`, `useSettings()`, etc.) rather than duplicating providers.

### Meteor 3.0+ Compatibility
Server-side publications must use async methods:
- `findOne()` → `findOneAsync()`
- `find().fetch()` → `find().fetchAsync()`

### TanStack Router Migration
- Uses programmatic routing with `createRouter` and `createRoute`
- Nested routes under `adminLayoutRoute` for admin section
- Authentication handled in `beforeLoad` hooks
- `AdminLayout` component wraps admin routes with `<Outlet />`

### Theme Loading Pattern
- `AdminLayout` sets `data.themeId` from route params
- `ThemeProvider` subscribes to theme data based on `themeId`
- Components should handle loading states when `theme` is undefined
- Loading states prevent crashes when accessing `theme._id` before data loads

### TypeScript + SimpleSchema Pattern
- TypeScript interfaces auto-generated in `imports/api/db/generated-types.ts`
- Collections defined in `imports/api/db/index.ts` with schemas attached
- Individual schema files only contain SimpleSchema definitions
- Optional fields in SimpleSchema (`required: false`) become optional in TypeScript (`field?: type`)
- Use `npm run generate-types` to regenerate types from schemas
- All types exported from `imports/api/db/index.ts`
- Custom type generator in `scripts/generate-types-real.ts` parses actual schema files
- Generator reads your real SimpleSchema definitions and generates accurate TypeScript interfaces
- Types are saved to `imports/types/schema.ts` (replaces old manual types in `imports/types.ts`)
- Utility types are in `imports/types/utils.ts` (separate from generated schema types)
- Main types index at `imports/types/index.ts` exports both schema and utility types
- No temporary files or stale data - either works with real schemas or fails cleanly
- All imports now use the generated schema types from `/imports/types`
- **CRITICAL**: Collections must be declared with proper generic types: `new Mongo.Collection<DataType>("collectionName")`
- Data types combine schema types with TrackableData: `type MemberData = Member & TrackableData`
- This ensures `find()` methods return properly typed cursors with no type casting needed
- Store types extend schema types with additional reactive properties for MobX integration
- All data types exported from `/imports/api/db` for consistent usage across providers

### TrackableStore/TrackableCollection Pattern
- Base reactive data management system for Meteor collections
- `extendObservable` automatically makes all data fields reactive without manual declarations
- Provides consistent `_id`-based CRUD operations across all store types
- Generic pattern allows type-safe extension for specific domain stores
- Integrates with Meteor's reactive data flow through `refreshData` method
- Collection constructors handle store instantiation with proper type assertions using `as new (data: TrackableData) => StoreType`
- Store constructors accept specific data types (MemberData, OrgData, etc.) for full type safety

### Documentation Rules
- ONLY document architectural decisions and WHY choices were made
- NEVER document implementation details, HOW things work, or specific code patterns
- If it would become outdated quickly or is obvious from reading the code, don't document it
- Focus on non-obvious reasoning behind architectural choices

### TypeScript Type Strategy
- Rely on TypeScript's type inference for derived types instead of explicit annotations
- Only add explicit types when TypeScript cannot infer them (e.g., generic constructors, complex union types)
- Avoid redundant type annotations that duplicate what the type system already knows
- Trust the compiler to derive types from initial values and context

### NEVER USE `any` - CRITICAL RULE
- **ABSOLUTELY FORBIDDEN**: Never use `any` as a type definition
- **NEVER EVER**: No exceptions, no shortcuts, no "just this once"
- **ALWAYS**: Use proper type assertions, union types, or generic constraints instead
- **IF STUCK**: Use `unknown` and narrow the type, or create proper interfaces
- **TYPE ASSERTIONS**: Use `as unknown as SpecificType` when necessary, never `as any`
- **GENERIC CONSTRAINTS**: Use proper generic bounds instead of `any`
- **INTERSECTION TYPES**: Use `TypeA & TypeB` for combining types
- **MAPPED TYPES**: Use utility types like `Partial<T>`, `Pick<T, K>`, `Omit<T, K>`
- **UNION TYPES**: Use `string | number` instead of `any`
- **RECORD TYPES**: Use `Record<string, unknown>` instead of `any`

### NO TYPE CASTING - CRITICAL RULE
- **ABSOLUTELY FORBIDDEN**: Type casting is NOT an acceptable way to handle TypeScript errors
- **NEVER CAST**: Do not use `as` to force types - this defeats the purpose of TypeScript
- **FIX THE ROOT CAUSE**: If you need to cast, the types are wrong - fix the actual type definitions
- **PROPER SOLUTIONS**: 
  - Fix the source type definitions to be correct
  - Use proper generic constraints
  - Create proper interfaces that match the actual data structure
  - Use type guards with `unknown` and narrowing
  - Use intersection types to combine existing types
- **WHEN STUCK**: If you think you need to cast, step back and fix the underlying type system
- **TYPE ASSERTIONS ONLY**: The only acceptable use of `as` is for type assertions with `unknown` when you've properly narrowed the type
- **NO SHORTCUTS**: Type casting is a shortcut that breaks type safety - never use it
